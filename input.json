{
    "language": "Solidity",
    "sources": {
        "@openzeppelin/contracts/access/Ownable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/Context.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/math/Math.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
        },
        "contracts/chatGPT_OV_v1.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract OutlawVoyage {\n    // 系统参数\n    uint256 public dealerFeePercentage;\n    bool public isGamePaused;\n\n    // 船班结构\n    struct Voyage {\n        uint256 voyageId;\n        uint256 entryFee;\n        uint256 startBlock;\n        uint256 waitingBlocks;\n        uint256 gameDurationBlocks;\n    }\n\n    // 船只结构\n    struct Ship {\n        uint256 shipId;\n        uint256 voyageId;\n        bool isSettled;\n        mapping(string => uint256) cardCounts; // 使用映射以节省Gas\n        uint256 playerCount;\n        uint256 tableCount;\n        mapping(uint256 => Table) tables;\n        mapping(address => Player) players;\n    }\n\n    // Table结构\n    struct Table {\n        uint256 tableId;\n        string firstHash;\n        string firstPlain;\n        string secondHash;\n        string secondPlain;\n        bool isFinished;\n    }\n\n    // 玩家结构\n    struct Player {\n        address walletAddress;\n        string tgId;\n        uint256 starCount;\n        string status; // 状态：游戏中，0星出局，犯规出局，胜，负\n        mapping(string => bool) cards; // 卡牌HASH\n    }\n\n    // 全局玩家清单\n    struct GlobalPlayer {\n        address walletAddress;\n        uint256 winCount;\n        uint256 loseCount;\n    }\n\n    // 交易结构\n    struct Trade {\n        uint256 tradeId;\n        string firstHash;\n        address firstOwner;\n        string secondHash;\n        address secondOwner;\n    }\n\n    // 船班列表\n    mapping(uint256 => Voyage) public voyages;\n    uint256 public nextVoyageId;\n\n    // 船只列表\n    mapping(uint256 => Ship) public ships;\n    uint256 public nextShipId;\n\n    // 全局玩家列表\n    mapping(address => GlobalPlayer) public globalPlayers;\n\n    // 交易大厅\n    mapping(uint256 => Trade) public trades;\n    uint256 public nextTradeId;\n\n    // Owner地址\n    address public owner;\n\n    // 构造函数\n    constructor(uint256 _dealerFeePercentage) {\n        owner = msg.sender;\n        dealerFeePercentage = _dealerFeePercentage;\n        isGamePaused = false;\n        nextVoyageId = 1;\n        nextShipId = 1;\n        nextTradeId = 1;\n    }\n\n    // 修改器：仅限Owner\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not authorized\");\n        _;\n    }\n\n    // 设置系统参数（仅限Owner）\n    function setSystemParams(uint256 _dealerFeePercentage, bool _isGamePaused) public onlyOwner {\n        dealerFeePercentage = _dealerFeePercentage;\n        isGamePaused = _isGamePaused;\n    }\n\n    // 设置船班（仅限Owner）\n    function setVoyage(uint256 entryFee, uint256 waitingBlocks, uint256 gameDurationBlocks) public onlyOwner {\n        voyages[nextVoyageId] = Voyage(nextVoyageId, entryFee, block.number, waitingBlocks, gameDurationBlocks);\n        nextVoyageId++;\n    }\n\n    // 创建船只\n    function createShip(uint256 voyageId) public {\n        require(!isGamePaused, \"Game is paused\");\n        require(voyages[voyageId].voyageId == voyageId, \"Voyage does not exist\");\n\n        ships[nextShipId].shipId = nextShipId;\n        ships[nextShipId].voyageId = voyageId;\n        ships[nextShipId].isSettled = false;\n        ships[nextShipId].playerCount = 0;\n        ships[nextShipId].tableCount = 0;\n\n        nextShipId++;\n    }\n\n    // 玩家报名\n    function registerPlayer(uint256 shipId, string memory tgId, string[] memory cardHashes) public payable {\n        require(!isGamePaused, \"Game is paused\");\n        require(ships[shipId].shipId == shipId, \"Ship does not exist\");\n        require(msg.value == voyages[ships[shipId].voyageId].entryFee, \"Incorrect entry fee\");\n\n        ships[shipId].players[msg.sender].walletAddress = msg.sender;\n        ships[shipId].players[msg.sender].tgId = tgId;\n        ships[shipId].players[msg.sender].starCount = 0;\n        ships[shipId].players[msg.sender].status = \"playing\";\n\n        for (uint256 i = 0; i < cardHashes.length; i++) {\n            ships[shipId].players[msg.sender].cards[cardHashes[i]] = true;\n        }\n\n        ships[shipId].playerCount++;\n    }\n\n    // 检查出牌的hash是否合规\n    function checkCardHash(uint256 shipId, string memory cardHash) public view returns (bool) {\n        require(ships[shipId].shipId == shipId, \"Ship does not exist\");\n        return ships[shipId].players[msg.sender].cards[cardHash];\n    }\n\n    // 明文检查\n    function checkPlain(uint256 shipId, string memory cardHash, string memory cardPlain) public view returns (bool) {\n        require(ships[shipId].shipId == shipId, \"Ship does not exist\");\n        // 使用keccak256检查hash\n        return keccak256(abi.encodePacked(cardPlain)) == keccak256(abi.encodePacked(cardHash));\n    }\n\n    // 创建Table\n    function createTable(uint256 shipId, string memory cardHash) public {\n        require(!isGamePaused, \"Game is paused\");\n        require(ships[shipId].shipId == shipId, \"Ship does not exist\");\n        require(!ships[shipId].isSettled, \"Ship is settled\");\n        require(ships[shipId].tables[ships[shipId].tableCount].isFinished, \"Table is active\");\n\n        ships[shipId].tables[ships[shipId].tableCount].tableId = ships[shipId].tableCount;\n        ships[shipId].tables[ships[shipId].tableCount].firstHash = cardHash;\n        ships[shipId].tableCount++;\n    }\n\n    // 加入Table\n    function joinTable(uint256 shipId, uint256 tableId, string memory cardHash) public {\n        require(!isGamePaused, \"Game is paused\");\n        require(ships[shipId].shipId == shipId, \"Ship does not exist\");\n        require(!ships[shipId].isSettled, \"Ship is settled\");\n        require(!ships[shipId].tables[tableId].isFinished, \"Table is finished\");\n        require(ships[shipId].players[msg.sender].cards[cardHash], \"Invalid card hash\");\n\n        ships[shipId].tables[tableId].secondHash = cardHash;\n    }\n\n    // 提交明文\n    function submitPlain(uint256 shipId, uint256 tableId, string memory cardPlain) public {\n        require(!isGamePaused, \"Game is paused\");\n        require(ships[shipId].shipId == shipId, \"Ship does not exist\");\n        require(!ships[shipId].isSettled, \"Ship is settled\");\n        require(!ships[shipId].tables[tableId].isFinished, \"Table is finished\");\n\n        Table storage table = ships[shipId].tables[tableId];\n        Player storage player = ships[shipId].players[msg.sender];\n\n        if (keccak256(abi.encodePacked(cardPlain)) == keccak256(abi.encodePacked(table.firstHash))) {\n            table.firstPlain = cardPlain;\n        } else if (keccak256(abi.encodePacked(cardPlain)) == keccak256(abi.encodePacked(table.secondHash))) {\n            table.secondPlain = cardPlain;\n            table.isFinished = true;\n            // 结算Table，这里简单地加一颗星星作为示例\n            player.starCount++;\n        } else {\n            revert(\"Invalid plain text\");\n        }\n    }\n\n    // 更多功能的实现可以继续扩展...\n\n    // 资金提取（仅限Owner）\n    function withdraw() public onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n}\n"
        },
        "contracts/Espoir.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\ncontract Espoir is Ownable, ReentrancyGuard {\n    using Math for uint256;\n\n    // 常量\n    uint8 private constant CARDS_PER_PLAYER = 12;\n    uint8 private constant WIN_STAR_THRESHOLD = 3;\n    string private constant GAME_STATUS_PLAYING = \"G\";\n    string private constant GAME_STATUS_ZERO_STAR = \"Z\";\n    string private constant GAME_STATUS_OUT = \"O\";\n    string private constant GAME_STATUS_WIN = \"W\";\n\n    // 系统相关\n    uint public houseCut; // 庄家抽成比例\n    bool public gamePaused; // 游戏是否暂停\n\n    // 事件通知\n    event HouseCutUpdated(uint256 newHouseCut);\n    event GamePauseStatusChanged(bool isPaused);\n    event VoyageCreated(uint indexed shipId, uint indexed voyageId);\n    event PlayerRegistered(uint indexed voyageId, address indexed player);\n    event TableCreated(uint indexed voyageId, uint indexed tableId);\n    event TradeCreated(\n        uint indexed voyageId,\n        string indexed tradeId,\n        TradeStatus status\n    );\n    event VoyageSettled(uint indexed shipId, uint indexed voyageId);\n\n    // 构造函数部署合约时的初始化\n    constructor(uint256 _houseCut, bool _gamePaused) Ownable(msg.sender) {\n        require(_houseCut <= 100, \"House cut must be <= 100\");\n        houseCut = _houseCut;\n        gamePaused = _gamePaused;\n    }\n\n    // 船相关\n    struct Ship {\n        uint entryFee; // 入场金\n        uint startStar; // 起始星星数\n        uint winStar; //获胜星星数\n        uint startBlock; // 起始区块\n        uint waitBlocks; // 等候报名时间（等候几个区块）\n        uint gameBlocks; // 游戏时间（历经几个区块）\n    }\n    mapping(uint => Ship) public ships; // 船映射\n\n    // Table相关\n    struct Table {\n        bytes32 firstHash; // 第一组Hash\n        string firstPlaintext; // 第一组明文\n        bytes32 secondHash; // 第二组Hash\n        string secondPlaintext; // 第二组明文\n        address firstOwner; // 第一组Hash归属钱包地址\n        address secondOwner; // 第二组Hash归属钱包地址\n        bool isEnded; // 是否结束\n    }\n\n    // 玩家信息\n    struct Player {\n        string tgId; // TG ID\n        uint stars; // 星星数量\n        string status; // 状态（游戏中:G，0星出局:Z，犯规出局:O，胜:W）\n        uint cardCount; //手上剩余牌数，如果完成一局Table，则扣1\n        mapping(bytes32 => bool) cards; // 卡牌（用卡牌HASH作为Key），如果换牌了，玩家旧牌false，并增加新牌\n        bool isRegistered; // 用来检查是否已报名\n        address walletAddress; // 玩家钱包地址\n\n    }\n\n    // 交易状态\n    enum TradeStatus {\n        FirstOwnCheckPass, // 第一方检查通过\n        SenondOwnCheckPass, // 第二方检查通过\n        ToBeConfirmed, // 双方检查通过，带确定交换\n        Completed // 交换完成\n    }\n\n    // 交易信息\n    struct Trade {\n        bytes32 firstHash; // 第一组Hash，原本归属钱包地址\n        address firstOwner; // 第一组Hash的 原本归属钱包地址\n        bytes32 secondHash; // 第二组Hash，原本归属钱包地址\n        address secondOwner; // 第二组Hash的原本归属钱包地址\n        bool isCompleted; //交易是否完成，避免有人一牌多换，最后检查双方牌归属都是正确的，Hash都是正确，才执行交换\n        TradeStatus status;\n    }\n    // 船班，一班就是一场游戏\n    struct Voyage {\n        uint shipId; // 船编号\n        bool isSettled; // 状态：是否结算\n        mapping(string => uint256) cardCounts; // R: 石头，P: 布，S:剪刀 卡牌数量（三种牌分开计数）使用映射以节省Gas\n        uint playerCount; // 全部玩家数量（不论死活）\n        uint playerOut; //出局玩家数量\n        uint tablesCount; //当前活跃桌数，如果Table被创建+1,如果Table对决结束-1，用来检查能不能开新桌\n        uint globaltbCount; //当前生成过的桌子总量\n        address[] playerArr; // 玩家数组\n        address[] winPlayerArr; // 胜利玩家地址数组\n        uint[] allTables; //存储当前正在活动的桌子的下标\n        mapping(uint => Table) tables; // Table映射\n        mapping(address => Player) players; // 玩家映射\n        mapping(string => Trade) trades; // 交易厅映射\n    }\n\n    mapping(uint => Voyage) public voyages; // 船班映射\n\n    // 全局玩家清单\n    struct GlobalPlayer {\n        uint wins; // 胜数\n        uint losses; // 败数\n    }\n\n    mapping(address => GlobalPlayer) public globalPlayers; // 全局玩家映射\n    mapping(uint=>mapping(address=>uint)) public lastPlayerVoyage;// 玩家在每艘船上最后一次玩的船班\n\n    // 系统相关功能\n    // 设定抽成比例，例如30，就是先扣除30%\n    function setHouseCut(uint256 _newHouseCut) external onlyOwner {\n        houseCut = _newHouseCut;\n        emit HouseCutUpdated(_newHouseCut);\n    }\n\n    // 获取抽成比例\n    function getHouseCut() public view returns (uint) {\n        return houseCut;\n    }\n\n    // 设置游戏暂停\n    function setGamePaused(bool _paused) external onlyOwner {\n        gamePaused = _paused;\n        emit GamePauseStatusChanged(_paused);\n    }\n\n    // 获取游戏暂停状态\n    function getGamePaused() public view returns (bool) {\n        return gamePaused;\n    }\n\n    // - 设计和开发船班的相关逻辑，包括编号、入场金、起始区块、等候报名时间和游戏时间等。\n    // - 负责创建船只的逻辑，包括船只的编号、状态、卡牌数量、玩家数量等。\n\n    // ******* 船只相关功能\n    // 创建船只\n    function createShip(\n        uint _id,\n        uint _entryFee,\n        uint _startStar,\n        uint _winStar,\n        uint _startBlock,\n        uint _waitBlocks,\n        uint _gameBlocks\n    ) public onlyOwner {\n        ships[_id] = Ship({\n            entryFee: _entryFee,\n            startStar: _startStar,\n            winStar: _winStar,\n            startBlock: _startBlock,\n            waitBlocks: _waitBlocks,\n            gameBlocks: _gameBlocks\n        });\n    }\n\n    // 获取Ship的信息\n    function getShip(\n        uint _shipId\n    )\n        public\n        view\n        returns (\n            uint entryFee,\n            uint startStar,\n            uint winStar,\n            uint startBlock,\n            uint waitBlocks,\n            uint gameBlocks\n        )\n    {\n        Ship storage ship = ships[_shipId];\n        return (\n            ship.entryFee,\n            ship.startStar,\n            ship.winStar,\n            ship.startBlock,\n            ship.waitBlocks,\n            ship.gameBlocks\n        );\n    }\n\n    // 获取Table的信息\n    function getTable(\n        uint _voyageId,\n        uint _tableId\n    )\n        public\n        view\n        returns (\n            bytes32 firstHash,\n            string memory firstPlaintext,\n            bytes32 secondHash,\n            string memory secondPlaintext,\n            address firstOwner,\n            address secondOwner,\n            bool isEnded\n        )\n    {\n        Table storage table = voyages[_voyageId].tables[_tableId];\n        return (\n            table.firstHash,\n            table.firstPlaintext,\n            table.secondHash,\n            table.secondPlaintext,\n            table.firstOwner,\n            table.secondOwner,\n            table.isEnded\n        );\n    }\n\n    // 获取Player的信息\n    function getPlayer(\n        uint _voyageId,\n        address _walletAddress\n    )\n        public\n        view\n        returns (\n            string memory tgId,\n            uint stars,\n            string memory status,\n            uint cardCount,\n            bool isRegistered,\n            address walletAddress\n        )\n    {\n        Player storage player = voyages[_voyageId].players[_walletAddress];\n        return (\n            player.tgId,\n            player.stars,\n            player.status,\n            player.cardCount,\n            player.isRegistered,\n            player.walletAddress\n        );\n    }\n\n    // 获取Trade的信息\n    function getTrade(\n        uint _voyageId,\n        string memory _tradeId\n    )\n        public\n        view\n        returns (\n            bytes32 firstHash,\n            address firstOwner,\n            bytes32 secondHash,\n            address secondOwner,\n            bool isCompleted,\n            TradeStatus status\n        )\n    {\n        Trade storage trade = voyages[_voyageId].trades[_tradeId];\n        return (\n            trade.firstHash,\n            trade.firstOwner,\n            trade.secondHash,\n            trade.secondOwner,\n            trade.isCompleted,\n            trade.status\n        );\n    }\n\n    // 获取 Voyage 的基本信息\n    function getVoyage(\n        uint _voyageId\n    )\n        public\n        view\n        returns (\n            uint shipId,\n            bool isSettled,\n            uint playerCount,\n            uint playerOut,\n            uint tablesCount\n        )\n    {\n        Voyage storage voyage = voyages[_voyageId];\n        return (\n            voyage.shipId,\n            voyage.isSettled,\n            voyage.playerCount,\n            voyage.playerOut,\n            voyage.tablesCount\n        );\n    }\n\n    // 获取 Voyage 的玩家数组\n    function getVoyagePlayerArr(\n        uint _voyageId\n    ) public view returns (address[] memory) {\n        return voyages[_voyageId].playerArr;\n    }\n\n    // 获取 Voyage 的胜利玩家数组\n    function getVoyageWinPlayerArr(\n        uint _voyageId\n    ) public view returns (address[] memory) {\n        return voyages[_voyageId].winPlayerArr;\n    }\n\n    // 获取 Voyage 的所有 Table ID 数组\n    function getVoyageAllTables(\n        uint _voyageId\n    ) public view returns (uint[] memory) {\n        return voyages[_voyageId].allTables;\n    }\n\n    // 获取特定 Voyage 中的卡牌计数\n    function getVoyageCardCount(\n        uint _voyageId,\n        string memory cardType\n    ) public view returns (uint256) {\n        return voyages[_voyageId].cardCounts[cardType];\n    }\n\n    //  获取指定玩家 全局输赢次数记录\n    function getGlobalPlayer(\n        address _walletAddress\n    ) public view returns (uint wins, uint losses) {\n        GlobalPlayer storage globalPlayer = globalPlayers[_walletAddress];\n        return (globalPlayer.wins, globalPlayer.losses);\n    }\n\n    function getNextVoyageId(\n        uint _shipId\n    ) public view returns (uint _voyageId) {\n        Ship memory ship = ships[_shipId];\n        require(ship.startBlock > 0, \"Invalid Ship ID\");\n\n        uint cycleLength = ship.waitBlocks + ship.gameBlocks;\n        uint currentBlock = block.number;\n        uint currentCycle = (currentBlock - ship.startBlock) / cycleLength;\n        uint NextVoyageId = currentCycle + 1;\n        return NextVoyageId;\n    }\n\n    // 船班相关功能\n    function createVoyage(uint _shipId, uint _voyageId) internal {\n        Voyage storage newVoyage = voyages[_voyageId];\n        newVoyage.shipId = _shipId;\n        newVoyage.isSettled = false;\n        newVoyage.playerArr = new address[](0);\n\n        emit VoyageCreated(_shipId, _voyageId);\n    }\n\n    // 检查船班编号是否合法\n    // 目前检查船只只能是下一场的，不能是过去的，也不能是下下场的\n    function isValidNextVoyageId(\n        uint _shipId,\n        uint _voyageId\n    ) public view returns (bool) {\n        Ship memory ship = ships[_shipId];\n        if (ship.startBlock == 0) return false; // 船不存在\n\n        uint cycleLength = ship.waitBlocks + ship.gameBlocks;\n        uint currentBlock = block.number;\n\n        // 计算当前周期编号\n        uint currentCycle = (currentBlock - ship.startBlock) / cycleLength;\n\n        // 下一场船班编号应该是当前周期编号加一\n        return _voyageId == currentCycle + 1;\n    }\n\n    // 玩家注册，如果还没有船班就创建一艘船\n    // function addCardToPlayer 前端产生12组牌跟hash，hash存入玩家的资料中，已经合并到registerPlayer\n\n    function registerPlayer(\n        uint _shipId,\n        uint _voyageId,\n        // address _walletAddress,\n        string memory _tgId,\n        bytes32[] memory _cardHashes\n    ) public payable nonReentrant {\n        require(isValidNextVoyageId(_shipId, _voyageId), \"Invalid voyage ID\");\n        require(!gamePaused, \"Game is paused\");\n        require(msg.value == ships[_shipId].entryFee, \"Incorrect entry fee\");\n        require(\n            _cardHashes.length == CARDS_PER_PLAYER,\n            \"Must provide exactly 12 card hashes\"\n        );\n        address _walletAddress = msg.sender;\n        Voyage storage voyage = voyages[_voyageId];\n        if (voyage.shipId == 0) {\n            // 默认情况下，如果voyage尚未初始化，shipId和isSettled应该是0和false\n            createVoyage(_shipId, _voyageId);\n        }\n        Player storage player = voyage.players[_walletAddress];\n        require(!player.isRegistered, \"Player already registered\");\n\n        // Ship memory ship = ships[_shipId];\n        // 检查卡片数量是否12张\n        for (uint i = 0; i < _cardHashes.length; i++) {\n            player.cards[_cardHashes[i]] = true;\n        }\n\n        // 更新玩家数据\n        player.tgId = _tgId;\n        player.stars = ships[_shipId].startStar; // 更新玩家星级\n        player.status = GAME_STATUS_PLAYING; // 更新玩家状态\n        player.cardCount = CARDS_PER_PLAYER; // 更新玩家卡片数量\n        player.isRegistered = true; // 标记玩家已报名\n        player.walletAddress = _walletAddress; // 更新玩家钱包地址\n\n        voyage.playerCount++;\n        voyage.playerArr.push(_walletAddress);\n        lastPlayerVoyage[_shipId][_walletAddress]=_voyageId;\n\n        // 更新卡牌数量\n        voyage.cardCounts[\"R\"] += 4;\n        voyage.cardCounts[\"P\"] += 4;\n        voyage.cardCounts[\"S\"] += 4;\n\n        emit PlayerRegistered(_voyageId, _walletAddress);\n    }\n\n   function updateRegisteredPlayer(\n        uint _shipId,\n        uint _voyageId,\n        string memory _tgId,\n        bytes32[] memory _cardHashes\n    ) public {\n        require(isValidNextVoyageId(_shipId, _voyageId), \"Invalid voyage ID\");\n        require(!gamePaused, \"Game is paused\");\n        require(\n            _cardHashes.length == CARDS_PER_PLAYER,\n            \"Must provide exactly 12 card hashes\"\n        );\n        address _walletAddress = msg.sender;\n        uint lastVoyageId = lastPlayerVoyage[_shipId][_walletAddress];\n        Voyage storage lastvoyage = voyages[lastVoyageId];\n        // 检查玩家上一场是否为一个人\n        require(lastvoyage.playerCount == 1,\"not eligible\");\n\n        Voyage storage voyage = voyages[_voyageId];\n        if (voyage.shipId == 0) {\n            // 默认情况下，如果voyage尚未初始化，shipId和isSettled应该是0和false\n            createVoyage(_shipId, _voyageId);\n        }\n        Player storage player = voyage.players[_walletAddress];\n        require(!player.isRegistered, \"Player already registered\");\n\n        // Ship memory ship = ships[_shipId];\n        // 检查卡片数量是否12张\n        for (uint i = 0; i < _cardHashes.length; i++) {\n            player.cards[_cardHashes[i]] = true;\n        }\n\n        // 更新玩家数据\n        player.tgId = _tgId;\n        player.stars = ships[_shipId].startStar; // 更新玩家星级\n        player.status = GAME_STATUS_PLAYING; // 更新玩家状态\n        player.cardCount = CARDS_PER_PLAYER; // 更新玩家卡片数量\n        player.isRegistered = true; // 标记玩家已报名\n        player.walletAddress = _walletAddress; // 更新玩家钱包地址\n\n        voyage.playerCount++;\n        voyage.playerArr.push(_walletAddress);\n        lastPlayerVoyage[_shipId][_walletAddress]=_voyageId;\n\n        // 更新卡牌数量\n        voyage.cardCounts[\"R\"] += 4;\n        voyage.cardCounts[\"P\"] += 4;\n        voyage.cardCounts[\"S\"] += 4;\n\n        emit PlayerRegistered(_voyageId, _walletAddress);\n    }\n\n\n    // TODO:创建Table\n    //     - 检查船班是否结算，已结算则无法进行\n    //     - 当前有效的Table如果大于存活人数的一半，则无法再新增Table\n    //     - 创建Table的玩家需要提交手上有效的卡牌Hash，无效hash则无法送出\n    function createTable(\n        uint _voyageId,\n        address _firstOwner,\n        bytes32 _firstHash\n    ) public returns (uint tableId) {\n        Voyage storage voyage = voyages[_voyageId];\n        // Player storage fistOwner = voyage.players[_firstOwner];\n        require(voyage.isSettled == false, \"Voyage already settled\");\n        require(voyage.tablesCount < voyage.playerCount / 2, \"Too many tables\");\n        require(\n            voyage.players[_firstOwner].cardCount > 0,\n            \"Player has no cards\"\n        );\n        voyage.tablesCount++;\n        voyage.globaltbCount++;\n        //提交有效的卡牌hash，提交前需要检查hash是否有效\n        require(\n            checkCardValidity(_voyageId, _firstOwner, _firstHash),\n            \"Invalid card hash\"\n        );\n        voyage.tables[voyage.globaltbCount] = Table({\n            firstHash: _firstHash,\n            firstPlaintext: \"\",\n            secondHash: bytes32(0),\n            secondPlaintext: \"\",\n            firstOwner: _firstOwner,\n            secondOwner: address(0),\n            isEnded: false\n        });\n\n        emit TableCreated(_voyageId, tableId);\n        return voyage.globaltbCount;\n    }\n\n    // TODO:加入Table\n    //     - 检查船班是否结算，已结算则无法进行\n    //     - 针对生效中的Table，提交有效的卡牌hash，提交前需要检查hash是否有效\n    function joinTable(\n        uint _voyageId,\n        uint _tableId,\n        address _secondOwner,\n        bytes32 _secondHash\n    ) public {\n        Voyage storage voyage = voyages[_voyageId];\n        require(voyage.isSettled == false, \"Voyage already settled\");\n        Table storage table = voyage.tables[_tableId];\n        require(table.isEnded == false, \"Table already ended\");\n        require(\n            voyage.players[_secondOwner].cardCount > 0,\n            \"Player has no cards\"\n        );\n        require(\n            checkCardValidity(_voyageId, _secondOwner, _secondHash),\n            \"Invalid card hash\"\n        );\n        table.secondHash = _secondHash;\n        table.secondOwner = _secondOwner;\n        //opentable\n    }\n\n    // TODO: Table Open，提交明文\n    //     - 两人中第一个提交明文，检查明文是否符合Hash\n    //     - 第二个提交明文，检查明文是否符合Hash，并结算Table\n    //     - 结算Table后，胜者加一颗星星\n    //     - 扣除船只上的牌型计数\n    function commitPlain(\n        uint _voyageId,\n        uint _tableId,\n        address _commiter,\n        string memory _plainText\n    ) public {\n        Voyage storage voyage = voyages[_voyageId];\n        require(voyage.isSettled == false, \"Voyage already settled\");\n        Table storage table = voyage.tables[_tableId];\n        require(table.isEnded == false, \"Table already ended\");\n        if (table.firstOwner == _commiter) {\n            if (!checkPlainText(table.firstHash, _plainText)) {\n                voyage.players[table.firstOwner].stars = 0;\n                table.isEnded = true;\n            }\n            table.firstPlaintext = _plainText;\n        } else if (table.secondOwner == _commiter) {\n            if (!checkPlainText(table.secondHash, _plainText)) {\n                voyage.players[table.secondOwner].status = \"O\";\n                table.isEnded = true;\n            }\n            table.secondPlaintext = _plainText;\n        }\n        bytes memory firstplainText = bytes(table.firstPlaintext);\n        bytes memory secondplainText = bytes(table.secondPlaintext);\n\n        if (\n            firstplainText.length != 0 &&\n            secondplainText.length != 0 &&\n            !table.isEnded &&\n            keccak256(bytes(voyage.players[table.firstOwner].status)) !=\n            keccak256(bytes(\"O\")) &&\n            keccak256(bytes(voyage.players[table.secondOwner].status)) !=\n            keccak256(bytes(\"O\"))\n        ) {\n            // 结算Table\n            //置空玩家使用了的卡牌\n            voyage.players[table.firstOwner].cards[table.firstHash] = false;\n            voyage.players[table.secondOwner].cards[table.secondHash] = false;\n            if (firstplainText[0] == secondplainText[0]) {\n                // 平局\n                voyage.players[table.firstOwner].cardCount--;\n                voyage.players[table.secondOwner].cardCount--;\n            } else {\n                // 胜者加一颗星星,输者扣一颗星星,比较石头剪刀布,扣除对应牌的计数\n                if (firstplainText[0] == \"R\" && secondplainText[0] == \"S\") {\n                    voyage.players[table.firstOwner].stars++;\n                    voyage.players[table.secondOwner].stars--;\n                    voyage.cardCounts[\"S\"]--;\n                } else if (\n                    firstplainText[0] == \"S\" && secondplainText[0] == \"P\"\n                ) {\n                    voyage.players[table.firstOwner].stars++;\n                    voyage.players[table.secondOwner].stars--;\n                    voyage.cardCounts[\"P\"]--;\n                } else if (\n                    firstplainText[0] == \"P\" && secondplainText[0] == \"R\"\n                ) {\n                    voyage.players[table.firstOwner].stars++;\n                    voyage.players[table.secondOwner].stars--;\n                    voyage.cardCounts[\"R\"]--;\n                } else {\n                    voyage.players[table.secondOwner].stars++;\n                    voyage.players[table.firstOwner].stars--;\n                    voyage.cardCounts[\"S\"]--;\n                }\n                voyage.players[table.firstOwner].cardCount--;\n                voyage.players[table.secondOwner].cardCount--;\n            }\n            table.isEnded = true;\n        }\n        //检查是否有玩家出局\n        //如果玩家星星为0，状态改为出局\n        if (voyage.players[table.firstOwner].stars == 0) {\n            voyage.players[table.firstOwner].status = \"Z\";\n            voyage.playerOut++;\n        }\n        if (voyage.players[table.secondOwner].stars == 0) {\n            voyage.players[table.secondOwner].status = \"Z\";\n            voyage.playerOut++;\n        }\n        //检查table是否结束，如果结束，tablesCount-1\n        if (table.isEnded == true) {\n            voyage.tablesCount--;\n        }\n    }\n\n    // 明文检查，玩家贴入明文后，确认牌跟Hash一致，不一致则违规出局！丧失资格\n    function checkPlainText(\n        bytes32 _cardHash,\n        string memory _plainText\n    ) public pure returns (bool) {\n        return keccak256(abi.encodePacked(_plainText)) == _cardHash;\n    }\n\n    // 创建交易\n    // 第二个人 贴 hash 交易也是这个逻辑\n    // 返回的第一个值为 交易 id ，第二个值为 交易状态\n    function createTread(\n        uint _shipId,\n        uint _voyageId,\n        string memory _tradeId,\n        address _walletAddress,\n        bytes32 _hash\n    ) public returns (string memory, TradeStatus) {\n        // 判断航班是否正常\n        Voyage storage voyage = voyages[_voyageId];\n        require(\n            voyage.shipId > 0 && voyage.shipId == _shipId,\n            \"Voyage not existed\"\n        );\n        require(voyage.isSettled == false, \"Voyage already settled\");\n        // 判断 玩家地址是否存在\n        Player storage owner = voyage.players[_walletAddress];\n        require(owner.walletAddress != address(0), \"address not existed\");\n        // 校验卡片\n        require(\n            checkCardValidity(_voyageId, _walletAddress, _hash) == true,\n            \"card not belong you\"\n        );\n        Trade memory tradeInfo = voyage.trades[_tradeId];\n        // 如果交易存在，就代表是第二个人来贴 hash 进行交易\n        // 如果交易不存在，就代表是第一个人来贴 hash 进行交易\n        if (tradeInfo.firstHash != \"\") {\n            tradeInfo.secondHash = _hash;\n            tradeInfo.secondOwner = _walletAddress;\n            tradeInfo.status = TradeStatus.SenondOwnCheckPass;\n        } else {\n            // 创建交易对象\n            tradeInfo = Trade({\n                firstHash: _hash,\n                secondHash: \"\",\n                firstOwner: _walletAddress,\n                secondOwner: address(0),\n                isCompleted: false,\n                status: TradeStatus.FirstOwnCheckPass\n            });\n            voyage.trades[_tradeId] = tradeInfo;\n        }\n        return (_tradeId, tradeInfo.status);\n    }\n\n    // 确认交易，交换归属\n    function confoirmTrade(\n        uint _shipId,\n        uint _voyageId,\n        string memory _tradeId,\n        address _walletAddress\n    ) public {\n        Voyage storage voyage = voyages[_voyageId];\n        require(\n            voyage.shipId > 0 && voyage.shipId == _shipId,\n            \"Voyage not existed\"\n        );\n        require(voyage.isSettled == false, \"Voyage already settled\");\n        Trade memory tradeInfo = voyage.trades[_tradeId];\n        require(\n            tradeInfo.status == TradeStatus.ToBeConfirmed,\n            \"Trade info error\"\n        );\n        // 判断地址是否交易中的一个\n        require(\n            tradeInfo.firstOwner == _walletAddress ||\n                tradeInfo.secondOwner == _walletAddress,\n            \"address is error\"\n        );\n        // 判断 2 张 hash 是否已经交换过\n        Player storage fistOwner = voyage.players[tradeInfo.firstOwner];\n        Player storage secondOwner = voyage.players[tradeInfo.secondOwner];\n        require(\n            fistOwner.cards[tradeInfo.firstHash] == true &&\n                secondOwner.cards[tradeInfo.secondHash] == true,\n            \"card hava been exchanged\"\n        );\n        // 修改归属\n        fistOwner.cards[tradeInfo.firstHash] = false;\n        fistOwner.cards[tradeInfo.secondHash] = true;\n        secondOwner.cards[tradeInfo.secondHash] = false;\n        secondOwner.cards[tradeInfo.firstHash] = true;\n    }\n\n    // 结算当前船只进度\n    // - 检查是否符合结算条件\n    // - 手里必须没有牌+星星必须大于等于 3 颗 才算赢，其他情况的都算输\n    // - 分配金额（按照胜者的星星总数评分）\n\n    function settleShip(uint _shipId, uint _voyageId) public payable {\n        // 判断航班是否正常\n        Voyage storage voyage = voyages[_voyageId];\n        require(voyage.shipId > 0, \"Voyage not existed\");\n        require(voyage.isSettled == false, \"Voyage already settled\");\n        // 获取船\n        Ship storage ship = ships[_shipId];\n        // 判断当前的区块是否大于等待区块+游戏时间区块\n        require(\n            block.number > ship.startBlock + ship.waitBlocks + ship.gameBlocks,\n            \"game not ended\"\n        );\n        // 判断输赢，遍历玩家\n        uint winStarCount = 0; // 全部胜星数量\n        uint totalEntryFee = (ship.entryFee *\n            voyage.playerArr.length *\n            houseCut) / 100; // 全部入场金\n        // 庄家获取 分成比例 new address[](0)\n        // 判断输赢，并记录相关的数据\n        for (uint256 i = 0; i < voyage.playerArr.length; i++) {\n            address playerAddress = voyage.playerArr[i];\n            Player storage player = voyage.players[playerAddress];\n            // 判断输赢\n            if (player.stars >= ship.winStar && player.cardCount == 0) {\n                globalPlayers[playerAddress].wins += 1;\n                winStarCount += player.stars;\n                voyage.winPlayerArr.push(playerAddress);\n            } else {\n                globalPlayers[playerAddress].losses += 1;\n            }\n        }\n        // 遍历转账\n        for (uint256 i = 0; i < voyage.winPlayerArr.length; i++) {\n            address playerAddress = voyage.winPlayerArr[i];\n            uint winAmount = (totalEntryFee *\n                voyage.players[playerAddress].stars) / winStarCount;\n            payable(playerAddress).transfer(winAmount);\n        }\n    }\n\n    // TODO: 庄家抽成储存到指定合约地址的功能 OwnerOnly（后续设计败部复活赛用）\n\n    //  检查牌是否合规\n    function checkCardValidity(\n        uint _voyageId,\n        address _walletAddress,\n        bytes32 _cardHash\n    ) public view returns (bool) {\n        Voyage storage voyage = voyages[_voyageId];\n        Player storage player = voyage.players[_walletAddress];\n        return player.cards[_cardHash];\n    }\n\n    // 全局玩家清单相关功能\n    function updateGlobalPlayer(address _walletAddress, bool _won) internal {\n        GlobalPlayer storage player = globalPlayers[_walletAddress];\n\n        // 如果玩家记录不存在，创建新记录\n        if (player.wins == 0 && player.losses == 0) {\n            globalPlayers[_walletAddress] = GlobalPlayer({\n                wins: _won ? 1 : 0,\n                losses: _won ? 0 : 1\n            });\n        } else {\n            // 更新已有记录\n            if (_won) {\n                player.wins += 1;\n            } else {\n                player.losses += 1;\n            }\n        }\n    }\n\n    // 提现功能\n    function withdraw(uint256 _amount) public onlyOwner {\n        require(_amount <= address(this).balance, \"Insufficient balance\");\n        payable(owner()).transfer(_amount);\n    }\n\n    receive() external payable {}\n}\n"
        },
        "contracts/Lock.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\n\ncontract Lock {\n    uint public unlockTime;\n    address payable public owner;\n\n    event Withdrawal(uint amount, uint when);\n\n    constructor(uint _unlockTime) payable {\n        require(\n            block.timestamp < _unlockTime,\n            \"Unlock time should be in the future\"\n        );\n\n        unlockTime = _unlockTime;\n        owner = payable(msg.sender);\n    }\n\n    function withdraw() public {\n        // Uncomment this line, and the import of \"hardhat/console.sol\", to print a log in your terminal\n        // console.log(\"Unlock time is %o and block timestamp is %o\", unlockTime, block.timestamp);\n\n        require(block.timestamp >= unlockTime, \"You can't withdraw yet\");\n        require(msg.sender == owner, \"You aren't the owner\");\n\n        emit Withdrawal(address(this).balance, block.timestamp);\n\n        owner.transfer(address(this).balance);\n    }\n}\n"
        },
        "contracts/utils.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n// 工具函数"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "evmVersion": "paris",
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers",
                    "metadata"
                ],
                "": [
                    "ast"
                ]
            }
        }
    }
}